diff -ruN flac-1.2.1/doc/html/Makefile.am flac-1.2.1.aros/doc/html/Makefile.am
--- flac-1.2.1/doc/html/Makefile.am	2007-09-16 20:14:01.000000000 +0100
+++ flac-1.2.1.aros/doc/html/Makefile.am	2012-06-11 01:30:15.303173400 +0100
@@ -73,7 +73,7 @@
 # handle 'api/' specially:
 install-data-local:
 	$(mkinstalldirs) $(DESTDIR)$(docdir)/api
-	(cd api && $(INSTALL_DATA) * $(DESTDIR)$(docdir)/api)
+#	(cd api && $(INSTALL_DATA) * $(DESTDIR)$(docdir)/api) # breaks the aros build
 uninstall-local:
 	rm -rf $(DESTDIR)$(docdir)/api
 maintainer-clean-local:
diff -ruN flac-1.2.1/doc/html/Makefile.am~ flac-1.2.1.aros/doc/html/Makefile.am~
--- flac-1.2.1/doc/html/Makefile.am~	1970-01-01 01:00:00.000000000 +0100
+++ flac-1.2.1.aros/doc/html/Makefile.am~	2012-06-11 01:30:15.294172900 +0100
@@ -0,0 +1,80 @@
+#  FLAC - Free Lossless Audio Codec
+#  Copyright (C) 2001,2002,2003,2004,2005,2006,2007  Josh Coalson
+#
+#  This file is part the FLAC project.  FLAC is comprised of several
+#  components distributed under difference licenses.  The codec libraries
+#  are distributed under Xiph.Org's BSD-like license (see the file
+#  COPYING.Xiph in this distribution).  All other programs, libraries, and
+#  plugins are distributed under the GPL (see COPYING.GPL).  The documentation
+#  is distributed under the Gnu FDL (see COPYING.FDL).  Each file in the
+#  FLAC distribution contains at the top the terms under which it may be
+#  distributed.
+#
+#  Since this particular file is relevant to all components of FLAC,
+#  it may be distributed under the Xiph.Org license, which is the least
+#  restrictive of those mentioned above.  See the file COPYING.Xiph in this
+#  distribution.
+
+AUTOMAKE_OPTIONS = foreign
+
+SUBDIRS = ru images
+
+docdir = $(datadir)/doc/$(PACKAGE)-$(VERSION)/html
+
+doc_DATA = \
+	changelog.html \
+	comparison.html \
+	comparison__chopin_prelude_24.html \
+	comparison__dream_theater_600.html \
+	comparison__eddie_warner_titus.html \
+	comparison__fanfare_de_l_eventail_de_jeanne.html \
+	comparison__gloria_estefan_conga.html \
+	comparison__hand_in_my_pocket.html \
+	comparison__l_sub_raga_sivapriya.html \
+	comparison__laetatus_sum.html \
+	comparison__mummified_in_barbed_wire.html \
+	comparison__prokofiev_pcon3_3.html \
+	comparison__ravel_sq4_4.html \
+	comparison__scarlatti_k42.html \
+	comparison__tool_forty_six_and_2.html \
+	comparison__white_room.html \
+	comparison_all_cpudectime.html \
+	comparison_all_cpuenctime.html \
+	comparison_all_procdectime.html \
+	comparison_all_procenctime.html \
+	comparison_all_ratio.html \
+	developers.html \
+	documentation.html \
+	documentation_bugs.html \
+	documentation_example_code.html \
+	documentation_format_overview.html \
+	documentation_tasks.html \
+	documentation_tools.html \
+	documentation_tools_flac.html \
+	documentation_tools_metaflac.html \
+	documentation_tools_plugins.html \
+	download.html \
+	faq.html \
+	favicon.ico \
+	features.html \
+	flac.css \
+	format.html \
+	id.html \
+	index.html \
+	itunes.html \
+	license.html \
+	links.html \
+	news.html \
+	ogg_mapping.html
+
+EXTRA_DIST = $(doc_DATA) api
+
+# The install targets don't copy whole directories so we have to
+# handle 'api/' specially:
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(docdir)/api
+	(cd api && $(INSTALL_DATA) * $(DESTDIR)$(docdir)/api)
+uninstall-local:
+	rm -rf $(DESTDIR)$(docdir)/api
+maintainer-clean-local:
+	rm -rf api
diff -ruN flac-1.2.1/doc/html/Makefile.in flac-1.2.1.aros/doc/html/Makefile.in
--- flac-1.2.1/doc/html/Makefile.in	2007-09-16 21:04:58.000000000 +0100
+++ flac-1.2.1.aros/doc/html/Makefile.in	2012-06-11 01:30:15.362176800 +0100
@@ -597,7 +597,7 @@
 # handle 'api/' specially:
 install-data-local:
 	$(mkinstalldirs) $(DESTDIR)$(docdir)/api
-	(cd api && $(INSTALL_DATA) * $(DESTDIR)$(docdir)/api)
+#	(cd api && $(INSTALL_DATA) * $(DESTDIR)$(docdir)/api) # breaks the aros build
 uninstall-local:
 	rm -rf $(DESTDIR)$(docdir)/api
 maintainer-clean-local:
diff -ruN flac-1.2.1/doc/html/Makefile.in~ flac-1.2.1.aros/doc/html/Makefile.in~
--- flac-1.2.1/doc/html/Makefile.in~	1970-01-01 01:00:00.000000000 +0100
+++ flac-1.2.1.aros/doc/html/Makefile.in~	2012-06-11 01:30:14.513128200 +0100
@@ -0,0 +1,607 @@
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#  FLAC - Free Lossless Audio Codec
+#  Copyright (C) 2001,2002,2003,2004,2005,2006,2007  Josh Coalson
+#
+#  This file is part the FLAC project.  FLAC is comprised of several
+#  components distributed under difference licenses.  The codec libraries
+#  are distributed under Xiph.Org's BSD-like license (see the file
+#  COPYING.Xiph in this distribution).  All other programs, libraries, and
+#  plugins are distributed under the GPL (see COPYING.GPL).  The documentation
+#  is distributed under the Gnu FDL (see COPYING.FDL).  Each file in the
+#  FLAC distribution contains at the top the terms under which it may be
+#  distributed.
+#
+#  Since this particular file is relevant to all components of FLAC,
+#  it may be distributed under the Xiph.Org license, which is the least
+#  restrictive of those mentioned above.  See the file COPYING.Xiph in this
+#  distribution.
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+ACLOCAL_AMFLAGS = @ACLOCAL_AMFLAGS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCAS = @CCAS@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEBUG_FALSE = @DEBUG_FALSE@
+DEBUG_TRUE = @DEBUG_TRUE@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOCBOOK_TO_MAN = @DOCBOOK_TO_MAN@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+FLAC__TEST_LEVEL = @FLAC__TEST_LEVEL@
+FLAC__TEST_WITH_VALGRIND = @FLAC__TEST_WITH_VALGRIND@
+FLaC__CPU_IA32_FALSE = @FLaC__CPU_IA32_FALSE@
+FLaC__CPU_IA32_TRUE = @FLaC__CPU_IA32_TRUE@
+FLaC__CPU_PPC_FALSE = @FLaC__CPU_PPC_FALSE@
+FLaC__CPU_PPC_TRUE = @FLaC__CPU_PPC_TRUE@
+FLaC__CPU_SPARC_FALSE = @FLaC__CPU_SPARC_FALSE@
+FLaC__CPU_SPARC_TRUE = @FLaC__CPU_SPARC_TRUE@
+FLaC__HAS_AS_FALSE = @FLaC__HAS_AS_FALSE@
+FLaC__HAS_AS_TRUE = @FLaC__HAS_AS_TRUE@
+FLaC__HAS_AS__TEMPORARILY_DISABLED_FALSE = @FLaC__HAS_AS__TEMPORARILY_DISABLED_FALSE@
+FLaC__HAS_AS__TEMPORARILY_DISABLED_TRUE = @FLaC__HAS_AS__TEMPORARILY_DISABLED_TRUE@
+FLaC__HAS_DOCBOOK_TO_MAN_FALSE = @FLaC__HAS_DOCBOOK_TO_MAN_FALSE@
+FLaC__HAS_DOCBOOK_TO_MAN_TRUE = @FLaC__HAS_DOCBOOK_TO_MAN_TRUE@
+FLaC__HAS_DOXYGEN_FALSE = @FLaC__HAS_DOXYGEN_FALSE@
+FLaC__HAS_DOXYGEN_TRUE = @FLaC__HAS_DOXYGEN_TRUE@
+FLaC__HAS_GAS_FALSE = @FLaC__HAS_GAS_FALSE@
+FLaC__HAS_GAS_TRUE = @FLaC__HAS_GAS_TRUE@
+FLaC__HAS_GAS__TEMPORARILY_DISABLED_FALSE = @FLaC__HAS_GAS__TEMPORARILY_DISABLED_FALSE@
+FLaC__HAS_GAS__TEMPORARILY_DISABLED_TRUE = @FLaC__HAS_GAS__TEMPORARILY_DISABLED_TRUE@
+FLaC__HAS_NASM_FALSE = @FLaC__HAS_NASM_FALSE@
+FLaC__HAS_NASM_TRUE = @FLaC__HAS_NASM_TRUE@
+FLaC__HAS_OGG_FALSE = @FLaC__HAS_OGG_FALSE@
+FLaC__HAS_OGG_TRUE = @FLaC__HAS_OGG_TRUE@
+FLaC__HAS_XMMS_FALSE = @FLaC__HAS_XMMS_FALSE@
+FLaC__HAS_XMMS_TRUE = @FLaC__HAS_XMMS_TRUE@
+FLaC__INSTALL_XMMS_PLUGIN_LOCALLY_FALSE = @FLaC__INSTALL_XMMS_PLUGIN_LOCALLY_FALSE@
+FLaC__INSTALL_XMMS_PLUGIN_LOCALLY_TRUE = @FLaC__INSTALL_XMMS_PLUGIN_LOCALLY_TRUE@
+FLaC__NO_ASM_FALSE = @FLaC__NO_ASM_FALSE@
+FLaC__NO_ASM_TRUE = @FLaC__NO_ASM_TRUE@
+FLaC__SSE_OS_FALSE = @FLaC__SSE_OS_FALSE@
+FLaC__SSE_OS_TRUE = @FLaC__SSE_OS_TRUE@
+FLaC__SYS_DARWIN_FALSE = @FLaC__SYS_DARWIN_FALSE@
+FLaC__SYS_DARWIN_TRUE = @FLaC__SYS_DARWIN_TRUE@
+FLaC__SYS_LINUX_FALSE = @FLaC__SYS_LINUX_FALSE@
+FLaC__SYS_LINUX_TRUE = @FLaC__SYS_LINUX_TRUE@
+FLaC__USE_3DNOW_FALSE = @FLaC__USE_3DNOW_FALSE@
+FLaC__USE_3DNOW_TRUE = @FLaC__USE_3DNOW_TRUE@
+FLaC__USE_ALTIVEC_FALSE = @FLaC__USE_ALTIVEC_FALSE@
+FLaC__USE_ALTIVEC_TRUE = @FLaC__USE_ALTIVEC_TRUE@
+FLaC__WITH_CPPLIBS_FALSE = @FLaC__WITH_CPPLIBS_FALSE@
+FLaC__WITH_CPPLIBS_TRUE = @FLaC__WITH_CPPLIBS_TRUE@
+GAS = @GAS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MINGW_WINSOCK_LIBS = @MINGW_WINSOCK_LIBS@
+NASM = @NASM@
+OBJEXT = @OBJEXT@
+OBJ_FORMAT = @OBJ_FORMAT@
+OGG_CFLAGS = @OGG_CFLAGS@
+OGG_LIBS = @OGG_LIBS@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+XMMS_CFLAGS = @XMMS_CFLAGS@
+XMMS_CONFIG = @XMMS_CONFIG@
+XMMS_DATA_DIR = @XMMS_DATA_DIR@
+XMMS_EFFECT_PLUGIN_DIR = @XMMS_EFFECT_PLUGIN_DIR@
+XMMS_GENERAL_PLUGIN_DIR = @XMMS_GENERAL_PLUGIN_DIR@
+XMMS_INPUT_PLUGIN_DIR = @XMMS_INPUT_PLUGIN_DIR@
+XMMS_LIBS = @XMMS_LIBS@
+XMMS_OUTPUT_PLUGIN_DIR = @XMMS_OUTPUT_PLUGIN_DIR@
+XMMS_PLUGIN_DIR = @XMMS_PLUGIN_DIR@
+XMMS_VERSION = @XMMS_VERSION@
+XMMS_VISUALIZATION_PLUGIN_DIR = @XMMS_VISUALIZATION_PLUGIN_DIR@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+
+AUTOMAKE_OPTIONS = foreign
+
+SUBDIRS = ru images
+
+docdir = $(datadir)/doc/$(PACKAGE)-$(VERSION)/html
+
+doc_DATA = \
+	changelog.html \
+	comparison.html \
+	comparison__chopin_prelude_24.html \
+	comparison__dream_theater_600.html \
+	comparison__eddie_warner_titus.html \
+	comparison__fanfare_de_l_eventail_de_jeanne.html \
+	comparison__gloria_estefan_conga.html \
+	comparison__hand_in_my_pocket.html \
+	comparison__l_sub_raga_sivapriya.html \
+	comparison__laetatus_sum.html \
+	comparison__mummified_in_barbed_wire.html \
+	comparison__prokofiev_pcon3_3.html \
+	comparison__ravel_sq4_4.html \
+	comparison__scarlatti_k42.html \
+	comparison__tool_forty_six_and_2.html \
+	comparison__white_room.html \
+	comparison_all_cpudectime.html \
+	comparison_all_cpuenctime.html \
+	comparison_all_procdectime.html \
+	comparison_all_procenctime.html \
+	comparison_all_ratio.html \
+	developers.html \
+	documentation.html \
+	documentation_bugs.html \
+	documentation_example_code.html \
+	documentation_format_overview.html \
+	documentation_tasks.html \
+	documentation_tools.html \
+	documentation_tools_flac.html \
+	documentation_tools_metaflac.html \
+	documentation_tools_plugins.html \
+	download.html \
+	faq.html \
+	favicon.ico \
+	features.html \
+	flac.css \
+	format.html \
+	id.html \
+	index.html \
+	itunes.html \
+	license.html \
+	links.html \
+	news.html \
+	ogg_mapping.html
+
+
+EXTRA_DIST = $(doc_DATA) api
+subdir = doc/html
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+DATA = $(doc_DATA)
+
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
+	ps-recursive install-info-recursive uninstall-info-recursive \
+	all-recursive install-data-recursive install-exec-recursive \
+	installdirs-recursive install-recursive uninstall-recursive \
+	check-recursive installcheck-recursive
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
+DIST_SUBDIRS = $(SUBDIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  doc/html/Makefile
+Makefile: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+docDATA_INSTALL = $(INSTALL_DATA)
+install-docDATA: $(doc_DATA)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(docdir)
+	@list='$(doc_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(docDATA_INSTALL) $$d$$p $(DESTDIR)$(docdir)/$$f"; \
+	  $(docDATA_INSTALL) $$d$$p $(DESTDIR)$(docdir)/$$f; \
+	done
+
+uninstall-docDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(doc_DATA)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(docdir)/$$f"; \
+	  rm -f $(DESTDIR)$(docdir)/$$f; \
+	done
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if (etags --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	else \
+	  include_option=--include; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(DATA)
+installdirs: installdirs-recursive
+installdirs-am:
+	$(mkinstalldirs) $(DESTDIR)$(docdir)
+
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-data-local install-docDATA
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic \
+	maintainer-clean-local
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-docDATA uninstall-info-am uninstall-local
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
+	clean-generic clean-libtool clean-recursive ctags \
+	ctags-recursive distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-local \
+	install-data-recursive install-docDATA install-exec \
+	install-exec-am install-exec-recursive install-info \
+	install-info-am install-info-recursive install-man \
+	install-recursive install-strip installcheck installcheck-am \
+	installdirs installdirs-am installdirs-recursive \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-local maintainer-clean-recursive mostlyclean \
+	mostlyclean-generic mostlyclean-libtool mostlyclean-recursive \
+	pdf pdf-am pdf-recursive ps ps-am ps-recursive tags \
+	tags-recursive uninstall uninstall-am uninstall-docDATA \
+	uninstall-info-am uninstall-info-recursive uninstall-local \
+	uninstall-recursive
+
+
+# The install targets don't copy whole directories so we have to
+# handle 'api/' specially:
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(docdir)/api
+	(cd api && $(INSTALL_DATA) * $(DESTDIR)$(docdir)/api)
+uninstall-local:
+	rm -rf $(DESTDIR)$(docdir)/api
+maintainer-clean-local:
+	rm -rf api
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -ruN flac-1.2.1/src/libFLAC/bitreader.c flac-1.2.1.aros/src/libFLAC/bitreader.c
--- flac-1.2.1/src/libFLAC/bitreader.c	2007-09-11 05:48:55.000000000 +0100
+++ flac-1.2.1.aros/src/libFLAC/bitreader.c	2012-06-11 01:30:16.612268300 +0100
@@ -42,6 +42,9 @@
 #elif defined __MINGW32__
 #include <winsock.h> /* for ntohl() */
 #else
+#if defined(__AROS__)
+#include <sys/types.h>
+#endif
 #include <netinet/in.h> /* for ntohl() */
 #endif
 #include "private/bitmath.h"
diff -ruN flac-1.2.1/src/libFLAC/bitreader.c~ flac-1.2.1.aros/src/libFLAC/bitreader.c~
--- flac-1.2.1/src/libFLAC/bitreader.c~	1970-01-01 01:00:00.000000000 +0100
+++ flac-1.2.1.aros/src/libFLAC/bitreader.c~	2012-06-11 01:30:16.484252100 +0100
@@ -0,0 +1,1376 @@
+/* libFLAC - Free Lossless Audio Codec library
+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006,2007  Josh Coalson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Xiph.org Foundation nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdlib.h> /* for malloc() */
+#include <string.h> /* for memcpy(), memset() */
+#ifdef _MSC_VER
+#include <winsock.h> /* for ntohl() */
+#elif defined FLAC__SYS_DARWIN
+#include <machine/endian.h> /* for ntohl() */
+#elif defined __MINGW32__
+#include <winsock.h> /* for ntohl() */
+#else
+#include <netinet/in.h> /* for ntohl() */
+#endif
+#include "private/bitmath.h"
+#include "private/bitreader.h"
+#include "private/crc.h"
+#include "FLAC/assert.h"
+
+/* Things should be fastest when this matches the machine word size */
+/* WATCHOUT: if you change this you must also change the following #defines down to COUNT_ZERO_MSBS below to match */
+/* WATCHOUT: there are a few places where the code will not work unless brword is >= 32 bits wide */
+/*           also, some sections currently only have fast versions for 4 or 8 bytes per word */
+typedef FLAC__uint32 brword;
+#define FLAC__BYTES_PER_WORD 4
+#define FLAC__BITS_PER_WORD 32
+#define FLAC__WORD_ALL_ONES ((FLAC__uint32)0xffffffff)
+/* SWAP_BE_WORD_TO_HOST swaps bytes in a brword (which is always big-endian) if necessary to match host byte order */
+#if WORDS_BIGENDIAN
+#define SWAP_BE_WORD_TO_HOST(x) (x)
+#else
+#ifdef _MSC_VER
+#define SWAP_BE_WORD_TO_HOST(x) local_swap32_(x)
+#else
+#define SWAP_BE_WORD_TO_HOST(x) ntohl(x)
+#endif
+#endif
+/* counts the # of zero MSBs in a word */
+#define COUNT_ZERO_MSBS(word) ( \
+	(word) <= 0xffff ? \
+		( (word) <= 0xff? byte_to_unary_table[word] + 24 : byte_to_unary_table[(word) >> 8] + 16 ) : \
+		( (word) <= 0xffffff? byte_to_unary_table[word >> 16] + 8 : byte_to_unary_table[(word) >> 24] ) \
+)
+/* this alternate might be slightly faster on some systems/compilers: */
+#define COUNT_ZERO_MSBS2(word) ( (word) <= 0xff ? byte_to_unary_table[word] + 24 : ((word) <= 0xffff ? byte_to_unary_table[(word) >> 8] + 16 : ((word) <= 0xffffff ? byte_to_unary_table[(word) >> 16] + 8 : byte_to_unary_table[(word) >> 24])) )
+
+
+/*
+ * This should be at least twice as large as the largest number of words
+ * required to represent any 'number' (in any encoding) you are going to
+ * read.  With FLAC this is on the order of maybe a few hundred bits.
+ * If the buffer is smaller than that, the decoder won't be able to read
+ * in a whole number that is in a variable length encoding (e.g. Rice).
+ * But to be practical it should be at least 1K bytes.
+ *
+ * Increase this number to decrease the number of read callbacks, at the
+ * expense of using more memory.  Or decrease for the reverse effect,
+ * keeping in mind the limit from the first paragraph.  The optimal size
+ * also depends on the CPU cache size and other factors; some twiddling
+ * may be necessary to squeeze out the best performance.
+ */
+static const unsigned FLAC__BITREADER_DEFAULT_CAPACITY = 65536u / FLAC__BITS_PER_WORD; /* in words */
+
+static const unsigned char byte_to_unary_table[] = {
+	8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+#ifdef min
+#undef min
+#endif
+#define min(x,y) ((x)<(y)?(x):(y))
+#ifdef max
+#undef max
+#endif
+#define max(x,y) ((x)>(y)?(x):(y))
+
+/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
+#ifdef _MSC_VER
+#define FLAC__U64L(x) x
+#else
+#define FLAC__U64L(x) x##LLU
+#endif
+
+#ifndef FLaC__INLINE
+#define FLaC__INLINE
+#endif
+
+/* WATCHOUT: assembly routines rely on the order in which these fields are declared */
+struct FLAC__BitReader {
+	/* any partially-consumed word at the head will stay right-justified as bits are consumed from the left */
+	/* any incomplete word at the tail will be left-justified, and bytes from the read callback are added on the right */
+	brword *buffer;
+	unsigned capacity; /* in words */
+	unsigned words; /* # of completed words in buffer */
+	unsigned bytes; /* # of bytes in incomplete word at buffer[words] */
+	unsigned consumed_words; /* #words ... */
+	unsigned consumed_bits; /* ... + (#bits of head word) already consumed from the front of buffer */
+	unsigned read_crc16; /* the running frame CRC */
+	unsigned crc16_align; /* the number of bits in the current consumed word that should not be CRC'd */
+	FLAC__BitReaderReadCallback read_callback;
+	void *client_data;
+	FLAC__CPUInfo cpu_info;
+};
+
+#ifdef _MSC_VER
+/* OPT: an MSVC built-in would be better */
+static _inline FLAC__uint32 local_swap32_(FLAC__uint32 x)
+{
+	x = ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);
+	return (x>>16) | (x<<16);
+}
+static void local_swap32_block_(FLAC__uint32 *start, FLAC__uint32 len)
+{
+	__asm {
+		mov edx, start
+		mov ecx, len
+		test ecx, ecx
+loop1:
+		jz done1
+		mov eax, [edx]
+		bswap eax
+		mov [edx], eax
+		add edx, 4
+		dec ecx
+		jmp short loop1
+done1:
+	}
+}
+#endif
+
+static FLaC__INLINE void crc16_update_word_(FLAC__BitReader *br, brword word)
+{
+	register unsigned crc = br->read_crc16;
+#if FLAC__BYTES_PER_WORD == 4
+	switch(br->crc16_align) {
+		case  0: crc = FLAC__CRC16_UPDATE((unsigned)(word >> 24), crc);
+		case  8: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 16) & 0xff), crc);
+		case 16: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 8) & 0xff), crc);
+		case 24: br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)(word & 0xff), crc);
+	}
+#elif FLAC__BYTES_PER_WORD == 8
+	switch(br->crc16_align) {
+		case  0: crc = FLAC__CRC16_UPDATE((unsigned)(word >> 56), crc);
+		case  8: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 48) & 0xff), crc);
+		case 16: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 40) & 0xff), crc);
+		case 24: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 32) & 0xff), crc);
+		case 32: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 24) & 0xff), crc);
+		case 40: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 16) & 0xff), crc);
+		case 48: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 8) & 0xff), crc);
+		case 56: br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)(word & 0xff), crc);
+	}
+#else
+	for( ; br->crc16_align < FLAC__BITS_PER_WORD; br->crc16_align += 8)
+		crc = FLAC__CRC16_UPDATE((unsigned)((word >> (FLAC__BITS_PER_WORD-8-br->crc16_align)) & 0xff), crc);
+	br->read_crc16 = crc;
+#endif
+	br->crc16_align = 0;
+}
+
+/* would be static except it needs to be called by asm routines */
+FLAC__bool bitreader_read_from_client_(FLAC__BitReader *br)
+{
+	unsigned start, end;
+	size_t bytes;
+	FLAC__byte *target;
+
+	/* first shift the unconsumed buffer data toward the front as much as possible */
+	if(br->consumed_words > 0) {
+		start = br->consumed_words;
+		end = br->words + (br->bytes? 1:0);
+		memmove(br->buffer, br->buffer+start, FLAC__BYTES_PER_WORD * (end - start));
+
+		br->words -= start;
+		br->consumed_words = 0;
+	}
+
+	/*
+	 * set the target for reading, taking into account word alignment and endianness
+	 */
+	bytes = (br->capacity - br->words) * FLAC__BYTES_PER_WORD - br->bytes;
+	if(bytes == 0)
+		return false; /* no space left, buffer is too small; see note for FLAC__BITREADER_DEFAULT_CAPACITY  */
+	target = ((FLAC__byte*)(br->buffer+br->words)) + br->bytes;
+
+	/* before reading, if the existing reader looks like this (say brword is 32 bits wide)
+	 *   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1 (partial tail word is left-justified)
+	 *   buffer[BE]:  11 22 33 44 55 ?? ?? ??   (shown layed out as bytes sequentially in memory)
+	 *   buffer[LE]:  44 33 22 11 ?? ?? ?? 55   (?? being don't-care)
+	 *                               ^^-------target, bytes=3
+	 * on LE machines, have to byteswap the odd tail word so nothing is
+	 * overwritten:
+	 */
+#if WORDS_BIGENDIAN
+#else
+	if(br->bytes)
+		br->buffer[br->words] = SWAP_BE_WORD_TO_HOST(br->buffer[br->words]);
+#endif
+
+	/* now it looks like:
+	 *   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1
+	 *   buffer[BE]:  11 22 33 44 55 ?? ?? ??
+	 *   buffer[LE]:  44 33 22 11 55 ?? ?? ??
+	 *                               ^^-------target, bytes=3
+	 */
+
+	/* read in the data; note that the callback may return a smaller number of bytes */
+	if(!br->read_callback(target, &bytes, br->client_data))
+		return false;
+
+	/* after reading bytes 66 77 88 99 AA BB CC DD EE FF from the client:
+	 *   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
+	 *   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??
+	 *   buffer[LE]:  44 33 22 11 55 66 77 88 99 AA BB CC DD EE FF ??
+	 * now have to byteswap on LE machines:
+	 */
+#if WORDS_BIGENDIAN
+#else
+	end = (br->words*FLAC__BYTES_PER_WORD + br->bytes + bytes + (FLAC__BYTES_PER_WORD-1)) / FLAC__BYTES_PER_WORD;
+# if defined(_MSC_VER) && (FLAC__BYTES_PER_WORD == 4)
+	if(br->cpu_info.type == FLAC__CPUINFO_TYPE_IA32 && br->cpu_info.data.ia32.bswap) {
+		start = br->words;
+		local_swap32_block_(br->buffer + start, end - start);
+	}
+	else
+# endif
+	for(start = br->words; start < end; start++)
+		br->buffer[start] = SWAP_BE_WORD_TO_HOST(br->buffer[start]);
+#endif
+
+	/* now it looks like:
+	 *   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
+	 *   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??
+	 *   buffer[LE]:  44 33 22 11 88 77 66 55 CC BB AA 99 ?? FF EE DD
+	 * finally we'll update the reader values:
+	 */
+	end = br->words*FLAC__BYTES_PER_WORD + br->bytes + bytes;
+	br->words = end / FLAC__BYTES_PER_WORD;
+	br->bytes = end % FLAC__BYTES_PER_WORD;
+
+	return true;
+}
+
+/***********************************************************************
+ *
+ * Class constructor/destructor
+ *
+ ***********************************************************************/
+
+FLAC__BitReader *FLAC__bitreader_new(void)
+{
+	FLAC__BitReader *br = (FLAC__BitReader*)calloc(1, sizeof(FLAC__BitReader));
+
+	/* calloc() implies:
+		memset(br, 0, sizeof(FLAC__BitReader));
+		br->buffer = 0;
+		br->capacity = 0;
+		br->words = br->bytes = 0;
+		br->consumed_words = br->consumed_bits = 0;
+		br->read_callback = 0;
+		br->client_data = 0;
+	*/
+	return br;
+}
+
+void FLAC__bitreader_delete(FLAC__BitReader *br)
+{
+	FLAC__ASSERT(0 != br);
+
+	FLAC__bitreader_free(br);
+	free(br);
+}
+
+/***********************************************************************
+ *
+ * Public class methods
+ *
+ ***********************************************************************/
+
+FLAC__bool FLAC__bitreader_init(FLAC__BitReader *br, FLAC__CPUInfo cpu, FLAC__BitReaderReadCallback rcb, void *cd)
+{
+	FLAC__ASSERT(0 != br);
+
+	br->words = br->bytes = 0;
+	br->consumed_words = br->consumed_bits = 0;
+	br->capacity = FLAC__BITREADER_DEFAULT_CAPACITY;
+	br->buffer = (brword*)malloc(sizeof(brword) * br->capacity);
+	if(br->buffer == 0)
+		return false;
+	br->read_callback = rcb;
+	br->client_data = cd;
+	br->cpu_info = cpu;
+
+	return true;
+}
+
+void FLAC__bitreader_free(FLAC__BitReader *br)
+{
+	FLAC__ASSERT(0 != br);
+
+	if(0 != br->buffer)
+		free(br->buffer);
+	br->buffer = 0;
+	br->capacity = 0;
+	br->words = br->bytes = 0;
+	br->consumed_words = br->consumed_bits = 0;
+	br->read_callback = 0;
+	br->client_data = 0;
+}
+
+FLAC__bool FLAC__bitreader_clear(FLAC__BitReader *br)
+{
+	br->words = br->bytes = 0;
+	br->consumed_words = br->consumed_bits = 0;
+	return true;
+}
+
+void FLAC__bitreader_dump(const FLAC__BitReader *br, FILE *out)
+{
+	unsigned i, j;
+	if(br == 0) {
+		fprintf(out, "bitreader is NULL\n");
+	}
+	else {
+		fprintf(out, "bitreader: capacity=%u words=%u bytes=%u consumed: words=%u, bits=%u\n", br->capacity, br->words, br->bytes, br->consumed_words, br->consumed_bits);
+
+		for(i = 0; i < br->words; i++) {
+			fprintf(out, "%08X: ", i);
+			for(j = 0; j < FLAC__BITS_PER_WORD; j++)
+				if(i < br->consumed_words || (i == br->consumed_words && j < br->consumed_bits))
+					fprintf(out, ".");
+				else
+					fprintf(out, "%01u", br->buffer[i] & (1 << (FLAC__BITS_PER_WORD-j-1)) ? 1:0);
+			fprintf(out, "\n");
+		}
+		if(br->bytes > 0) {
+			fprintf(out, "%08X: ", i);
+			for(j = 0; j < br->bytes*8; j++)
+				if(i < br->consumed_words || (i == br->consumed_words && j < br->consumed_bits))
+					fprintf(out, ".");
+				else
+					fprintf(out, "%01u", br->buffer[i] & (1 << (br->bytes*8-j-1)) ? 1:0);
+			fprintf(out, "\n");
+		}
+	}
+}
+
+void FLAC__bitreader_reset_read_crc16(FLAC__BitReader *br, FLAC__uint16 seed)
+{
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	FLAC__ASSERT((br->consumed_bits & 7) == 0);
+
+	br->read_crc16 = (unsigned)seed;
+	br->crc16_align = br->consumed_bits;
+}
+
+FLAC__uint16 FLAC__bitreader_get_read_crc16(FLAC__BitReader *br)
+{
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	FLAC__ASSERT((br->consumed_bits & 7) == 0);
+	FLAC__ASSERT(br->crc16_align <= br->consumed_bits);
+
+	/* CRC any tail bytes in a partially-consumed word */
+	if(br->consumed_bits) {
+		const brword tail = br->buffer[br->consumed_words];
+		for( ; br->crc16_align < br->consumed_bits; br->crc16_align += 8)
+			br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)((tail >> (FLAC__BITS_PER_WORD-8-br->crc16_align)) & 0xff), br->read_crc16);
+	}
+	return br->read_crc16;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitreader_is_consumed_byte_aligned(const FLAC__BitReader *br)
+{
+	return ((br->consumed_bits & 7) == 0);
+}
+
+FLaC__INLINE unsigned FLAC__bitreader_bits_left_for_byte_alignment(const FLAC__BitReader *br)
+{
+	return 8 - (br->consumed_bits & 7);
+}
+
+FLaC__INLINE unsigned FLAC__bitreader_get_input_bits_unconsumed(const FLAC__BitReader *br)
+{
+	return (br->words-br->consumed_words)*FLAC__BITS_PER_WORD + br->bytes*8 - br->consumed_bits;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitreader_read_raw_uint32(FLAC__BitReader *br, FLAC__uint32 *val, unsigned bits)
+{
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+
+	FLAC__ASSERT(bits <= 32);
+	FLAC__ASSERT((br->capacity*FLAC__BITS_PER_WORD) * 2 >= bits);
+	FLAC__ASSERT(br->consumed_words <= br->words);
+
+	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
+	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
+
+	if(bits == 0) { /* OPT: investigate if this can ever happen, maybe change to assertion */
+		*val = 0;
+		return true;
+	}
+
+	while((br->words-br->consumed_words)*FLAC__BITS_PER_WORD + br->bytes*8 - br->consumed_bits < bits) {
+		if(!bitreader_read_from_client_(br))
+			return false;
+	}
+	if(br->consumed_words < br->words) { /* if we've not consumed up to a partial tail word... */
+		/* OPT: taking out the consumed_bits==0 "else" case below might make things faster if less code allows the compiler to inline this function */
+		if(br->consumed_bits) {
+			/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
+			const unsigned n = FLAC__BITS_PER_WORD - br->consumed_bits;
+			const brword word = br->buffer[br->consumed_words];
+			if(bits < n) {
+				*val = (word & (FLAC__WORD_ALL_ONES >> br->consumed_bits)) >> (n-bits);
+				br->consumed_bits += bits;
+				return true;
+			}
+			*val = word & (FLAC__WORD_ALL_ONES >> br->consumed_bits);
+			bits -= n;
+			crc16_update_word_(br, word);
+			br->consumed_words++;
+			br->consumed_bits = 0;
+			if(bits) { /* if there are still bits left to read, there have to be less than 32 so they will all be in the next word */
+				*val <<= bits;
+				*val |= (br->buffer[br->consumed_words] >> (FLAC__BITS_PER_WORD-bits));
+				br->consumed_bits = bits;
+			}
+			return true;
+		}
+		else {
+			const brword word = br->buffer[br->consumed_words];
+			if(bits < FLAC__BITS_PER_WORD) {
+				*val = word >> (FLAC__BITS_PER_WORD-bits);
+				br->consumed_bits = bits;
+				return true;
+			}
+			/* at this point 'bits' must be == FLAC__BITS_PER_WORD; because of previous assertions, it can't be larger */
+			*val = word;
+			crc16_update_word_(br, word);
+			br->consumed_words++;
+			return true;
+		}
+	}
+	else {
+		/* in this case we're starting our read at a partial tail word;
+		 * the reader has guaranteed that we have at least 'bits' bits
+		 * available to read, which makes this case simpler.
+		 */
+		/* OPT: taking out the consumed_bits==0 "else" case below might make things faster if less code allows the compiler to inline this function */
+		if(br->consumed_bits) {
+			/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
+			FLAC__ASSERT(br->consumed_bits + bits <= br->bytes*8);
+			*val = (br->buffer[br->consumed_words] & (FLAC__WORD_ALL_ONES >> br->consumed_bits)) >> (FLAC__BITS_PER_WORD-br->consumed_bits-bits);
+			br->consumed_bits += bits;
+			return true;
+		}
+		else {
+			*val = br->buffer[br->consumed_words] >> (FLAC__BITS_PER_WORD-bits);
+			br->consumed_bits += bits;
+			return true;
+		}
+	}
+}
+
+FLAC__bool FLAC__bitreader_read_raw_int32(FLAC__BitReader *br, FLAC__int32 *val, unsigned bits)
+{
+	/* OPT: inline raw uint32 code here, or make into a macro if possible in the .h file */
+	if(!FLAC__bitreader_read_raw_uint32(br, (FLAC__uint32*)val, bits))
+		return false;
+	/* sign-extend: */
+	*val <<= (32-bits);
+	*val >>= (32-bits);
+	return true;
+}
+
+FLAC__bool FLAC__bitreader_read_raw_uint64(FLAC__BitReader *br, FLAC__uint64 *val, unsigned bits)
+{
+	FLAC__uint32 hi, lo;
+
+	if(bits > 32) {
+		if(!FLAC__bitreader_read_raw_uint32(br, &hi, bits-32))
+			return false;
+		if(!FLAC__bitreader_read_raw_uint32(br, &lo, 32))
+			return false;
+		*val = hi;
+		*val <<= 32;
+		*val |= lo;
+	}
+	else {
+		if(!FLAC__bitreader_read_raw_uint32(br, &lo, bits))
+			return false;
+		*val = lo;
+	}
+	return true;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitreader_read_uint32_little_endian(FLAC__BitReader *br, FLAC__uint32 *val)
+{
+	FLAC__uint32 x8, x32 = 0;
+
+	/* this doesn't need to be that fast as currently it is only used for vorbis comments */
+
+	if(!FLAC__bitreader_read_raw_uint32(br, &x32, 8))
+		return false;
+
+	if(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))
+		return false;
+	x32 |= (x8 << 8);
+
+	if(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))
+		return false;
+	x32 |= (x8 << 16);
+
+	if(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))
+		return false;
+	x32 |= (x8 << 24);
+
+	*val = x32;
+	return true;
+}
+
+FLAC__bool FLAC__bitreader_skip_bits_no_crc(FLAC__BitReader *br, unsigned bits)
+{
+	/*
+	 * OPT: a faster implementation is possible but probably not that useful
+	 * since this is only called a couple of times in the metadata readers.
+	 */
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+
+	if(bits > 0) {
+		const unsigned n = br->consumed_bits & 7;
+		unsigned m;
+		FLAC__uint32 x;
+
+		if(n != 0) {
+			m = min(8-n, bits);
+			if(!FLAC__bitreader_read_raw_uint32(br, &x, m))
+				return false;
+			bits -= m;
+		}
+		m = bits / 8;
+		if(m > 0) {
+			if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(br, m))
+				return false;
+			bits %= 8;
+		}
+		if(bits > 0) {
+			if(!FLAC__bitreader_read_raw_uint32(br, &x, bits))
+				return false;
+		}
+	}
+
+	return true;
+}
+
+FLAC__bool FLAC__bitreader_skip_byte_block_aligned_no_crc(FLAC__BitReader *br, unsigned nvals)
+{
+	FLAC__uint32 x;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(br));
+
+	/* step 1: skip over partial head word to get word aligned */
+	while(nvals && br->consumed_bits) { /* i.e. run until we read 'nvals' bytes or we hit the end of the head word */
+		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+			return false;
+		nvals--;
+	}
+	if(0 == nvals)
+		return true;
+	/* step 2: skip whole words in chunks */
+	while(nvals >= FLAC__BYTES_PER_WORD) {
+		if(br->consumed_words < br->words) {
+			br->consumed_words++;
+			nvals -= FLAC__BYTES_PER_WORD;
+		}
+		else if(!bitreader_read_from_client_(br))
+			return false;
+	}
+	/* step 3: skip any remainder from partial tail bytes */
+	while(nvals) {
+		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+			return false;
+		nvals--;
+	}
+
+	return true;
+}
+
+FLAC__bool FLAC__bitreader_read_byte_block_aligned_no_crc(FLAC__BitReader *br, FLAC__byte *val, unsigned nvals)
+{
+	FLAC__uint32 x;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(br));
+
+	/* step 1: read from partial head word to get word aligned */
+	while(nvals && br->consumed_bits) { /* i.e. run until we read 'nvals' bytes or we hit the end of the head word */
+		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+			return false;
+		*val++ = (FLAC__byte)x;
+		nvals--;
+	}
+	if(0 == nvals)
+		return true;
+	/* step 2: read whole words in chunks */
+	while(nvals >= FLAC__BYTES_PER_WORD) {
+		if(br->consumed_words < br->words) {
+			const brword word = br->buffer[br->consumed_words++];
+#if FLAC__BYTES_PER_WORD == 4
+			val[0] = (FLAC__byte)(word >> 24);
+			val[1] = (FLAC__byte)(word >> 16);
+			val[2] = (FLAC__byte)(word >> 8);
+			val[3] = (FLAC__byte)word;
+#elif FLAC__BYTES_PER_WORD == 8
+			val[0] = (FLAC__byte)(word >> 56);
+			val[1] = (FLAC__byte)(word >> 48);
+			val[2] = (FLAC__byte)(word >> 40);
+			val[3] = (FLAC__byte)(word >> 32);
+			val[4] = (FLAC__byte)(word >> 24);
+			val[5] = (FLAC__byte)(word >> 16);
+			val[6] = (FLAC__byte)(word >> 8);
+			val[7] = (FLAC__byte)word;
+#else
+			for(x = 0; x < FLAC__BYTES_PER_WORD; x++)
+				val[x] = (FLAC__byte)(word >> (8*(FLAC__BYTES_PER_WORD-x-1)));
+#endif
+			val += FLAC__BYTES_PER_WORD;
+			nvals -= FLAC__BYTES_PER_WORD;
+		}
+		else if(!bitreader_read_from_client_(br))
+			return false;
+	}
+	/* step 3: read any remainder from partial tail bytes */
+	while(nvals) {
+		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+			return false;
+		*val++ = (FLAC__byte)x;
+		nvals--;
+	}
+
+	return true;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitreader_read_unary_unsigned(FLAC__BitReader *br, unsigned *val)
+#if 0 /* slow but readable version */
+{
+	unsigned bit;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+
+	*val = 0;
+	while(1) {
+		if(!FLAC__bitreader_read_bit(br, &bit))
+			return false;
+		if(bit)
+			break;
+		else
+			*val++;
+	}
+	return true;
+}
+#else
+{
+	unsigned i;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+
+	*val = 0;
+	while(1) {
+		while(br->consumed_words < br->words) { /* if we've not consumed up to a partial tail word... */
+			brword b = br->buffer[br->consumed_words] << br->consumed_bits;
+			if(b) {
+				i = COUNT_ZERO_MSBS(b);
+				*val += i;
+				i++;
+				br->consumed_bits += i;
+				if(br->consumed_bits >= FLAC__BITS_PER_WORD) { /* faster way of testing if(br->consumed_bits == FLAC__BITS_PER_WORD) */
+					crc16_update_word_(br, br->buffer[br->consumed_words]);
+					br->consumed_words++;
+					br->consumed_bits = 0;
+				}
+				return true;
+			}
+			else {
+				*val += FLAC__BITS_PER_WORD - br->consumed_bits;
+				crc16_update_word_(br, br->buffer[br->consumed_words]);
+				br->consumed_words++;
+				br->consumed_bits = 0;
+				/* didn't find stop bit yet, have to keep going... */
+			}
+		}
+		/* at this point we've eaten up all the whole words; have to try
+		 * reading through any tail bytes before calling the read callback.
+		 * this is a repeat of the above logic adjusted for the fact we
+		 * don't have a whole word.  note though if the client is feeding
+		 * us data a byte at a time (unlikely), br->consumed_bits may not
+		 * be zero.
+		 */
+		if(br->bytes) {
+			const unsigned end = br->bytes * 8;
+			brword b = (br->buffer[br->consumed_words] & (FLAC__WORD_ALL_ONES << (FLAC__BITS_PER_WORD-end))) << br->consumed_bits;
+			if(b) {
+				i = COUNT_ZERO_MSBS(b);
+				*val += i;
+				i++;
+				br->consumed_bits += i;
+				FLAC__ASSERT(br->consumed_bits < FLAC__BITS_PER_WORD);
+				return true;
+			}
+			else {
+				*val += end - br->consumed_bits;
+				br->consumed_bits += end;
+				FLAC__ASSERT(br->consumed_bits < FLAC__BITS_PER_WORD);
+				/* didn't find stop bit yet, have to keep going... */
+			}
+		}
+		if(!bitreader_read_from_client_(br))
+			return false;
+	}
+}
+#endif
+
+FLAC__bool FLAC__bitreader_read_rice_signed(FLAC__BitReader *br, int *val, unsigned parameter)
+{
+	FLAC__uint32 lsbs = 0, msbs = 0;
+	unsigned uval;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	FLAC__ASSERT(parameter <= 31);
+
+	/* read the unary MSBs and end bit */
+	if(!FLAC__bitreader_read_unary_unsigned(br, &msbs))
+		return false;
+
+	/* read the binary LSBs */
+	if(!FLAC__bitreader_read_raw_uint32(br, &lsbs, parameter))
+		return false;
+
+	/* compose the value */
+	uval = (msbs << parameter) | lsbs;
+	if(uval & 1)
+		*val = -((int)(uval >> 1)) - 1;
+	else
+		*val = (int)(uval >> 1);
+
+	return true;
+}
+
+/* this is by far the most heavily used reader call.  it ain't pretty but it's fast */
+/* a lot of the logic is copied, then adapted, from FLAC__bitreader_read_unary_unsigned() and FLAC__bitreader_read_raw_uint32() */
+FLAC__bool FLAC__bitreader_read_rice_signed_block(FLAC__BitReader *br, int vals[], unsigned nvals, unsigned parameter)
+/* OPT: possibly faster version for use with MSVC */
+#ifdef _MSC_VER
+{
+	unsigned i;
+	unsigned uval = 0;
+	unsigned bits; /* the # of binary LSBs left to read to finish a rice codeword */
+
+	/* try and get br->consumed_words and br->consumed_bits into register;
+	 * must remember to flush them back to *br before calling other
+	 * bitwriter functions that use them, and before returning */
+	register unsigned cwords;
+	register unsigned cbits;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
+	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
+	FLAC__ASSERT(parameter < 32);
+	/* the above two asserts also guarantee that the binary part never straddles more that 2 words, so we don't have to loop to read it */
+
+	if(nvals == 0)
+		return true;
+
+	cbits = br->consumed_bits;
+	cwords = br->consumed_words;
+
+	while(1) {
+
+		/* read unary part */
+		while(1) {
+			while(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
+				brword b = br->buffer[cwords] << cbits;
+				if(b) {
+#if 0 /* slower, probably due to bad register allocation... */ && defined FLAC__CPU_IA32 && !defined FLAC__NO_ASM && FLAC__BITS_PER_WORD == 32
+					__asm {
+						bsr eax, b
+						not eax
+						and eax, 31
+						mov i, eax
+					}
+#else
+					i = COUNT_ZERO_MSBS(b);
+#endif
+					uval += i;
+					bits = parameter;
+					i++;
+					cbits += i;
+					if(cbits == FLAC__BITS_PER_WORD) {
+						crc16_update_word_(br, br->buffer[cwords]);
+						cwords++;
+						cbits = 0;
+					}
+					goto break1;
+				}
+				else {
+					uval += FLAC__BITS_PER_WORD - cbits;
+					crc16_update_word_(br, br->buffer[cwords]);
+					cwords++;
+					cbits = 0;
+					/* didn't find stop bit yet, have to keep going... */
+				}
+			}
+			/* at this point we've eaten up all the whole words; have to try
+			 * reading through any tail bytes before calling the read callback.
+			 * this is a repeat of the above logic adjusted for the fact we
+			 * don't have a whole word.  note though if the client is feeding
+			 * us data a byte at a time (unlikely), br->consumed_bits may not
+			 * be zero.
+			 */
+			if(br->bytes) {
+				const unsigned end = br->bytes * 8;
+				brword b = (br->buffer[cwords] & (FLAC__WORD_ALL_ONES << (FLAC__BITS_PER_WORD-end))) << cbits;
+				if(b) {
+					i = COUNT_ZERO_MSBS(b);
+					uval += i;
+					bits = parameter;
+					i++;
+					cbits += i;
+					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
+					goto break1;
+				}
+				else {
+					uval += end - cbits;
+					cbits += end;
+					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
+					/* didn't find stop bit yet, have to keep going... */
+				}
+			}
+			/* flush registers and read; bitreader_read_from_client_() does
+			 * not touch br->consumed_bits at all but we still need to set
+			 * it in case it fails and we have to return false.
+			 */
+			br->consumed_bits = cbits;
+			br->consumed_words = cwords;
+			if(!bitreader_read_from_client_(br))
+				return false;
+			cwords = br->consumed_words;
+		}
+break1:
+		/* read binary part */
+		FLAC__ASSERT(cwords <= br->words);
+
+		if(bits) {
+			while((br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits < bits) {
+				/* flush registers and read; bitreader_read_from_client_() does
+				 * not touch br->consumed_bits at all but we still need to set
+				 * it in case it fails and we have to return false.
+				 */
+				br->consumed_bits = cbits;
+				br->consumed_words = cwords;
+				if(!bitreader_read_from_client_(br))
+					return false;
+				cwords = br->consumed_words;
+			}
+			if(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
+				if(cbits) {
+					/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
+					const unsigned n = FLAC__BITS_PER_WORD - cbits;
+					const brword word = br->buffer[cwords];
+					if(bits < n) {
+						uval <<= bits;
+						uval |= (word & (FLAC__WORD_ALL_ONES >> cbits)) >> (n-bits);
+						cbits += bits;
+						goto break2;
+					}
+					uval <<= n;
+					uval |= word & (FLAC__WORD_ALL_ONES >> cbits);
+					bits -= n;
+					crc16_update_word_(br, word);
+					cwords++;
+					cbits = 0;
+					if(bits) { /* if there are still bits left to read, there have to be less than 32 so they will all be in the next word */
+						uval <<= bits;
+						uval |= (br->buffer[cwords] >> (FLAC__BITS_PER_WORD-bits));
+						cbits = bits;
+					}
+					goto break2;
+				}
+				else {
+					FLAC__ASSERT(bits < FLAC__BITS_PER_WORD);
+					uval <<= bits;
+					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-bits);
+					cbits = bits;
+					goto break2;
+				}
+			}
+			else {
+				/* in this case we're starting our read at a partial tail word;
+				 * the reader has guaranteed that we have at least 'bits' bits
+				 * available to read, which makes this case simpler.
+				 */
+				uval <<= bits;
+				if(cbits) {
+					/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
+					FLAC__ASSERT(cbits + bits <= br->bytes*8);
+					uval |= (br->buffer[cwords] & (FLAC__WORD_ALL_ONES >> cbits)) >> (FLAC__BITS_PER_WORD-cbits-bits);
+					cbits += bits;
+					goto break2;
+				}
+				else {
+					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-bits);
+					cbits += bits;
+					goto break2;
+				}
+			}
+		}
+break2:
+		/* compose the value */
+		*vals = (int)(uval >> 1 ^ -(int)(uval & 1));
+
+		/* are we done? */
+		--nvals;
+		if(nvals == 0) {
+			br->consumed_bits = cbits;
+			br->consumed_words = cwords;
+			return true;
+		}
+
+		uval = 0;
+		++vals;
+
+	}
+}
+#else
+{
+	unsigned i;
+	unsigned uval = 0;
+
+	/* try and get br->consumed_words and br->consumed_bits into register;
+	 * must remember to flush them back to *br before calling other
+	 * bitwriter functions that use them, and before returning */
+	register unsigned cwords;
+	register unsigned cbits;
+	unsigned ucbits; /* keep track of the number of unconsumed bits in the buffer */
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
+	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
+	FLAC__ASSERT(parameter < 32);
+	/* the above two asserts also guarantee that the binary part never straddles more than 2 words, so we don't have to loop to read it */
+
+	if(nvals == 0)
+		return true;
+
+	cbits = br->consumed_bits;
+	cwords = br->consumed_words;
+	ucbits = (br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits;
+
+	while(1) {
+
+		/* read unary part */
+		while(1) {
+			while(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
+				brword b = br->buffer[cwords] << cbits;
+				if(b) {
+#if 0 /* is not discernably faster... */ && defined FLAC__CPU_IA32 && !defined FLAC__NO_ASM && FLAC__BITS_PER_WORD == 32 && defined __GNUC__
+					asm volatile (
+						"bsrl %1, %0;"
+						"notl %0;"
+						"andl $31, %0;"
+						: "=r"(i)
+						: "r"(b)
+					);
+#else
+					i = COUNT_ZERO_MSBS(b);
+#endif
+					uval += i;
+					cbits += i;
+					cbits++; /* skip over stop bit */
+					if(cbits >= FLAC__BITS_PER_WORD) { /* faster way of testing if(cbits == FLAC__BITS_PER_WORD) */
+						crc16_update_word_(br, br->buffer[cwords]);
+						cwords++;
+						cbits = 0;
+					}
+					goto break1;
+				}
+				else {
+					uval += FLAC__BITS_PER_WORD - cbits;
+					crc16_update_word_(br, br->buffer[cwords]);
+					cwords++;
+					cbits = 0;
+					/* didn't find stop bit yet, have to keep going... */
+				}
+			}
+			/* at this point we've eaten up all the whole words; have to try
+			 * reading through any tail bytes before calling the read callback.
+			 * this is a repeat of the above logic adjusted for the fact we
+			 * don't have a whole word.  note though if the client is feeding
+			 * us data a byte at a time (unlikely), br->consumed_bits may not
+			 * be zero.
+			 */
+			if(br->bytes) {
+				const unsigned end = br->bytes * 8;
+				brword b = (br->buffer[cwords] & ~(FLAC__WORD_ALL_ONES >> end)) << cbits;
+				if(b) {
+					i = COUNT_ZERO_MSBS(b);
+					uval += i;
+					cbits += i;
+					cbits++; /* skip over stop bit */
+					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
+					goto break1;
+				}
+				else {
+					uval += end - cbits;
+					cbits += end;
+					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
+					/* didn't find stop bit yet, have to keep going... */
+				}
+			}
+			/* flush registers and read; bitreader_read_from_client_() does
+			 * not touch br->consumed_bits at all but we still need to set
+			 * it in case it fails and we have to return false.
+			 */
+			br->consumed_bits = cbits;
+			br->consumed_words = cwords;
+			if(!bitreader_read_from_client_(br))
+				return false;
+			cwords = br->consumed_words;
+			ucbits = (br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits + uval;
+			/* + uval to offset our count by the # of unary bits already
+			 * consumed before the read, because we will add these back
+			 * in all at once at break1
+			 */
+		}
+break1:
+		ucbits -= uval;
+		ucbits--; /* account for stop bit */
+
+		/* read binary part */
+		FLAC__ASSERT(cwords <= br->words);
+
+		if(parameter) {
+			while(ucbits < parameter) {
+				/* flush registers and read; bitreader_read_from_client_() does
+				 * not touch br->consumed_bits at all but we still need to set
+				 * it in case it fails and we have to return false.
+				 */
+				br->consumed_bits = cbits;
+				br->consumed_words = cwords;
+				if(!bitreader_read_from_client_(br))
+					return false;
+				cwords = br->consumed_words;
+				ucbits = (br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits;
+			}
+			if(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
+				if(cbits) {
+					/* this also works when consumed_bits==0, it's just slower than necessary for that case */
+					const unsigned n = FLAC__BITS_PER_WORD - cbits;
+					const brword word = br->buffer[cwords];
+					if(parameter < n) {
+						uval <<= parameter;
+						uval |= (word & (FLAC__WORD_ALL_ONES >> cbits)) >> (n-parameter);
+						cbits += parameter;
+					}
+					else {
+						uval <<= n;
+						uval |= word & (FLAC__WORD_ALL_ONES >> cbits);
+						crc16_update_word_(br, word);
+						cwords++;
+						cbits = parameter - n;
+						if(cbits) { /* parameter > n, i.e. if there are still bits left to read, there have to be less than 32 so they will all be in the next word */
+							uval <<= cbits;
+							uval |= (br->buffer[cwords] >> (FLAC__BITS_PER_WORD-cbits));
+						}
+					}
+				}
+				else {
+					cbits = parameter;
+					uval <<= parameter;
+					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-cbits);
+				}
+			}
+			else {
+				/* in this case we're starting our read at a partial tail word;
+				 * the reader has guaranteed that we have at least 'parameter'
+				 * bits available to read, which makes this case simpler.
+				 */
+				uval <<= parameter;
+				if(cbits) {
+					/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
+					FLAC__ASSERT(cbits + parameter <= br->bytes*8);
+					uval |= (br->buffer[cwords] & (FLAC__WORD_ALL_ONES >> cbits)) >> (FLAC__BITS_PER_WORD-cbits-parameter);
+					cbits += parameter;
+				}
+				else {
+					cbits = parameter;
+					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-cbits);
+				}
+			}
+		}
+
+		ucbits -= parameter;
+
+		/* compose the value */
+		*vals = (int)(uval >> 1 ^ -(int)(uval & 1));
+
+		/* are we done? */
+		--nvals;
+		if(nvals == 0) {
+			br->consumed_bits = cbits;
+			br->consumed_words = cwords;
+			return true;
+		}
+
+		uval = 0;
+		++vals;
+
+	}
+}
+#endif
+
+#if 0 /* UNUSED */
+FLAC__bool FLAC__bitreader_read_golomb_signed(FLAC__BitReader *br, int *val, unsigned parameter)
+{
+	FLAC__uint32 lsbs = 0, msbs = 0;
+	unsigned bit, uval, k;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+
+	k = FLAC__bitmath_ilog2(parameter);
+
+	/* read the unary MSBs and end bit */
+	if(!FLAC__bitreader_read_unary_unsigned(br, &msbs))
+		return false;
+
+	/* read the binary LSBs */
+	if(!FLAC__bitreader_read_raw_uint32(br, &lsbs, k))
+		return false;
+
+	if(parameter == 1u<<k) {
+		/* compose the value */
+		uval = (msbs << k) | lsbs;
+	}
+	else {
+		unsigned d = (1 << (k+1)) - parameter;
+		if(lsbs >= d) {
+			if(!FLAC__bitreader_read_bit(br, &bit))
+				return false;
+			lsbs <<= 1;
+			lsbs |= bit;
+			lsbs -= d;
+		}
+		/* compose the value */
+		uval = msbs * parameter + lsbs;
+	}
+
+	/* unfold unsigned to signed */
+	if(uval & 1)
+		*val = -((int)(uval >> 1)) - 1;
+	else
+		*val = (int)(uval >> 1);
+
+	return true;
+}
+
+FLAC__bool FLAC__bitreader_read_golomb_unsigned(FLAC__BitReader *br, unsigned *val, unsigned parameter)
+{
+	FLAC__uint32 lsbs, msbs = 0;
+	unsigned bit, k;
+
+	FLAC__ASSERT(0 != br);
+	FLAC__ASSERT(0 != br->buffer);
+
+	k = FLAC__bitmath_ilog2(parameter);
+
+	/* read the unary MSBs and end bit */
+	if(!FLAC__bitreader_read_unary_unsigned(br, &msbs))
+		return false;
+
+	/* read the binary LSBs */
+	if(!FLAC__bitreader_read_raw_uint32(br, &lsbs, k))
+		return false;
+
+	if(parameter == 1u<<k) {
+		/* compose the value */
+		*val = (msbs << k) | lsbs;
+	}
+	else {
+		unsigned d = (1 << (k+1)) - parameter;
+		if(lsbs >= d) {
+			if(!FLAC__bitreader_read_bit(br, &bit))
+				return false;
+			lsbs <<= 1;
+			lsbs |= bit;
+			lsbs -= d;
+		}
+		/* compose the value */
+		*val = msbs * parameter + lsbs;
+	}
+
+	return true;
+}
+#endif /* UNUSED */
+
+/* on return, if *val == 0xffffffff then the utf-8 sequence was invalid, but the return value will be true */
+FLAC__bool FLAC__bitreader_read_utf8_uint32(FLAC__BitReader *br, FLAC__uint32 *val, FLAC__byte *raw, unsigned *rawlen)
+{
+	FLAC__uint32 v = 0;
+	FLAC__uint32 x;
+	unsigned i;
+
+	if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+		return false;
+	if(raw)
+		raw[(*rawlen)++] = (FLAC__byte)x;
+	if(!(x & 0x80)) { /* 0xxxxxxx */
+		v = x;
+		i = 0;
+	}
+	else if(x & 0xC0 && !(x & 0x20)) { /* 110xxxxx */
+		v = x & 0x1F;
+		i = 1;
+	}
+	else if(x & 0xE0 && !(x & 0x10)) { /* 1110xxxx */
+		v = x & 0x0F;
+		i = 2;
+	}
+	else if(x & 0xF0 && !(x & 0x08)) { /* 11110xxx */
+		v = x & 0x07;
+		i = 3;
+	}
+	else if(x & 0xF8 && !(x & 0x04)) { /* 111110xx */
+		v = x & 0x03;
+		i = 4;
+	}
+	else if(x & 0xFC && !(x & 0x02)) { /* 1111110x */
+		v = x & 0x01;
+		i = 5;
+	}
+	else {
+		*val = 0xffffffff;
+		return true;
+	}
+	for( ; i; i--) {
+		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+			return false;
+		if(raw)
+			raw[(*rawlen)++] = (FLAC__byte)x;
+		if(!(x & 0x80) || (x & 0x40)) { /* 10xxxxxx */
+			*val = 0xffffffff;
+			return true;
+		}
+		v <<= 6;
+		v |= (x & 0x3F);
+	}
+	*val = v;
+	return true;
+}
+
+/* on return, if *val == 0xffffffffffffffff then the utf-8 sequence was invalid, but the return value will be true */
+FLAC__bool FLAC__bitreader_read_utf8_uint64(FLAC__BitReader *br, FLAC__uint64 *val, FLAC__byte *raw, unsigned *rawlen)
+{
+	FLAC__uint64 v = 0;
+	FLAC__uint32 x;
+	unsigned i;
+
+	if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+		return false;
+	if(raw)
+		raw[(*rawlen)++] = (FLAC__byte)x;
+	if(!(x & 0x80)) { /* 0xxxxxxx */
+		v = x;
+		i = 0;
+	}
+	else if(x & 0xC0 && !(x & 0x20)) { /* 110xxxxx */
+		v = x & 0x1F;
+		i = 1;
+	}
+	else if(x & 0xE0 && !(x & 0x10)) { /* 1110xxxx */
+		v = x & 0x0F;
+		i = 2;
+	}
+	else if(x & 0xF0 && !(x & 0x08)) { /* 11110xxx */
+		v = x & 0x07;
+		i = 3;
+	}
+	else if(x & 0xF8 && !(x & 0x04)) { /* 111110xx */
+		v = x & 0x03;
+		i = 4;
+	}
+	else if(x & 0xFC && !(x & 0x02)) { /* 1111110x */
+		v = x & 0x01;
+		i = 5;
+	}
+	else if(x & 0xFE && !(x & 0x01)) { /* 11111110 */
+		v = 0;
+		i = 6;
+	}
+	else {
+		*val = FLAC__U64L(0xffffffffffffffff);
+		return true;
+	}
+	for( ; i; i--) {
+		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
+			return false;
+		if(raw)
+			raw[(*rawlen)++] = (FLAC__byte)x;
+		if(!(x & 0x80) || (x & 0x40)) { /* 10xxxxxx */
+			*val = FLAC__U64L(0xffffffffffffffff);
+			return true;
+		}
+		v <<= 6;
+		v |= (x & 0x3F);
+	}
+	*val = v;
+	return true;
+}
diff -ruN flac-1.2.1/src/libFLAC/bitwriter.c flac-1.2.1.aros/src/libFLAC/bitwriter.c
--- flac-1.2.1/src/libFLAC/bitwriter.c	2007-09-11 00:08:38.000000000 +0100
+++ flac-1.2.1.aros/src/libFLAC/bitwriter.c	2012-06-11 01:30:16.634771200 +0100
@@ -42,6 +42,9 @@
 #elif defined __MINGW32__
 #include <winsock.h> /* for ntohl() */
 #else
+#if defined(__AROS__)
+#include <sys/types.h>
+#endif
 #include <netinet/in.h> /* for ntohl() */
 #endif
 #if 0 /* UNUSED */
diff -ruN flac-1.2.1/src/libFLAC/bitwriter.c~ flac-1.2.1.aros/src/libFLAC/bitwriter.c~
--- flac-1.2.1/src/libFLAC/bitwriter.c~	1970-01-01 01:00:00.000000000 +0100
+++ flac-1.2.1.aros/src/libFLAC/bitwriter.c~	2012-06-11 01:30:16.587765200 +0100
@@ -0,0 +1,889 @@
+/* libFLAC - Free Lossless Audio Codec library
+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006,2007  Josh Coalson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * - Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Xiph.org Foundation nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdlib.h> /* for malloc() */
+#include <string.h> /* for memcpy(), memset() */
+#ifdef _MSC_VER
+#include <winsock.h> /* for ntohl() */
+#elif defined FLAC__SYS_DARWIN
+#include <machine/endian.h> /* for ntohl() */
+#elif defined __MINGW32__
+#include <winsock.h> /* for ntohl() */
+#else
+#include <netinet/in.h> /* for ntohl() */
+#endif
+#if 0 /* UNUSED */
+#include "private/bitmath.h"
+#endif
+#include "private/bitwriter.h"
+#include "private/crc.h"
+#include "FLAC/assert.h"
+#include "share/alloc.h"
+
+/* Things should be fastest when this matches the machine word size */
+/* WATCHOUT: if you change this you must also change the following #defines down to SWAP_BE_WORD_TO_HOST below to match */
+/* WATCHOUT: there are a few places where the code will not work unless bwword is >= 32 bits wide */
+typedef FLAC__uint32 bwword;
+#define FLAC__BYTES_PER_WORD 4
+#define FLAC__BITS_PER_WORD 32
+#define FLAC__WORD_ALL_ONES ((FLAC__uint32)0xffffffff)
+/* SWAP_BE_WORD_TO_HOST swaps bytes in a bwword (which is always big-endian) if necessary to match host byte order */
+#if WORDS_BIGENDIAN
+#define SWAP_BE_WORD_TO_HOST(x) (x)
+#else
+#ifdef _MSC_VER
+#define SWAP_BE_WORD_TO_HOST(x) local_swap32_(x)
+#else
+#define SWAP_BE_WORD_TO_HOST(x) ntohl(x)
+#endif
+#endif
+
+/*
+ * The default capacity here doesn't matter too much.  The buffer always grows
+ * to hold whatever is written to it.  Usually the encoder will stop adding at
+ * a frame or metadata block, then write that out and clear the buffer for the
+ * next one.
+ */
+static const unsigned FLAC__BITWRITER_DEFAULT_CAPACITY = 32768u / sizeof(bwword); /* size in words */
+/* When growing, increment 4K at a time */
+static const unsigned FLAC__BITWRITER_DEFAULT_INCREMENT = 4096u / sizeof(bwword); /* size in words */
+
+#define FLAC__WORDS_TO_BITS(words) ((words) * FLAC__BITS_PER_WORD)
+#define FLAC__TOTAL_BITS(bw) (FLAC__WORDS_TO_BITS((bw)->words) + (bw)->bits)
+
+#ifdef min
+#undef min
+#endif
+#define min(x,y) ((x)<(y)?(x):(y))
+
+/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
+#ifdef _MSC_VER
+#define FLAC__U64L(x) x
+#else
+#define FLAC__U64L(x) x##LLU
+#endif
+
+#ifndef FLaC__INLINE
+#define FLaC__INLINE
+#endif
+
+struct FLAC__BitWriter {
+	bwword *buffer;
+	bwword accum; /* accumulator; bits are right-justified; when full, accum is appended to buffer */
+	unsigned capacity; /* capacity of buffer in words */
+	unsigned words; /* # of complete words in buffer */
+	unsigned bits; /* # of used bits in accum */
+};
+
+#ifdef _MSC_VER
+/* OPT: an MSVC built-in would be better */
+static _inline FLAC__uint32 local_swap32_(FLAC__uint32 x)
+{
+	x = ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);
+	return (x>>16) | (x<<16);
+}
+#endif
+
+/* * WATCHOUT: The current implementation only grows the buffer. */
+static FLAC__bool bitwriter_grow_(FLAC__BitWriter *bw, unsigned bits_to_add)
+{
+	unsigned new_capacity;
+	bwword *new_buffer;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+
+	/* calculate total words needed to store 'bits_to_add' additional bits */
+	new_capacity = bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD);
+
+	/* it's possible (due to pessimism in the growth estimation that
+	 * leads to this call) that we don't actually need to grow
+	 */
+	if(bw->capacity >= new_capacity)
+		return true;
+
+	/* round up capacity increase to the nearest FLAC__BITWRITER_DEFAULT_INCREMENT */
+	if((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT)
+		new_capacity += FLAC__BITWRITER_DEFAULT_INCREMENT - ((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);
+	/* make sure we got everything right */
+	FLAC__ASSERT(0 == (new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);
+	FLAC__ASSERT(new_capacity > bw->capacity);
+	FLAC__ASSERT(new_capacity >= bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD));
+
+	new_buffer = (bwword*)safe_realloc_mul_2op_(bw->buffer, sizeof(bwword), /*times*/new_capacity);
+	if(new_buffer == 0)
+		return false;
+	bw->buffer = new_buffer;
+	bw->capacity = new_capacity;
+	return true;
+}
+
+
+/***********************************************************************
+ *
+ * Class constructor/destructor
+ *
+ ***********************************************************************/
+
+FLAC__BitWriter *FLAC__bitwriter_new(void)
+{
+	FLAC__BitWriter *bw = (FLAC__BitWriter*)calloc(1, sizeof(FLAC__BitWriter));
+	/* note that calloc() sets all members to 0 for us */
+	return bw;
+}
+
+void FLAC__bitwriter_delete(FLAC__BitWriter *bw)
+{
+	FLAC__ASSERT(0 != bw);
+
+	FLAC__bitwriter_free(bw);
+	free(bw);
+}
+
+/***********************************************************************
+ *
+ * Public class methods
+ *
+ ***********************************************************************/
+
+FLAC__bool FLAC__bitwriter_init(FLAC__BitWriter *bw)
+{
+	FLAC__ASSERT(0 != bw);
+
+	bw->words = bw->bits = 0;
+	bw->capacity = FLAC__BITWRITER_DEFAULT_CAPACITY;
+	bw->buffer = (bwword*)malloc(sizeof(bwword) * bw->capacity);
+	if(bw->buffer == 0)
+		return false;
+
+	return true;
+}
+
+void FLAC__bitwriter_free(FLAC__BitWriter *bw)
+{
+	FLAC__ASSERT(0 != bw);
+
+	if(0 != bw->buffer)
+		free(bw->buffer);
+	bw->buffer = 0;
+	bw->capacity = 0;
+	bw->words = bw->bits = 0;
+}
+
+void FLAC__bitwriter_clear(FLAC__BitWriter *bw)
+{
+	bw->words = bw->bits = 0;
+}
+
+void FLAC__bitwriter_dump(const FLAC__BitWriter *bw, FILE *out)
+{
+	unsigned i, j;
+	if(bw == 0) {
+		fprintf(out, "bitwriter is NULL\n");
+	}
+	else {
+		fprintf(out, "bitwriter: capacity=%u words=%u bits=%u total_bits=%u\n", bw->capacity, bw->words, bw->bits, FLAC__TOTAL_BITS(bw));
+
+		for(i = 0; i < bw->words; i++) {
+			fprintf(out, "%08X: ", i);
+			for(j = 0; j < FLAC__BITS_PER_WORD; j++)
+				fprintf(out, "%01u", bw->buffer[i] & (1 << (FLAC__BITS_PER_WORD-j-1)) ? 1:0);
+			fprintf(out, "\n");
+		}
+		if(bw->bits > 0) {
+			fprintf(out, "%08X: ", i);
+			for(j = 0; j < bw->bits; j++)
+				fprintf(out, "%01u", bw->accum & (1 << (bw->bits-j-1)) ? 1:0);
+			fprintf(out, "\n");
+		}
+	}
+}
+
+FLAC__bool FLAC__bitwriter_get_write_crc16(FLAC__BitWriter *bw, FLAC__uint16 *crc)
+{
+	const FLAC__byte *buffer;
+	size_t bytes;
+
+	FLAC__ASSERT((bw->bits & 7) == 0); /* assert that we're byte-aligned */
+
+	if(!FLAC__bitwriter_get_buffer(bw, &buffer, &bytes))
+		return false;
+
+	*crc = (FLAC__uint16)FLAC__crc16(buffer, bytes);
+	FLAC__bitwriter_release_buffer(bw);
+	return true;
+}
+
+FLAC__bool FLAC__bitwriter_get_write_crc8(FLAC__BitWriter *bw, FLAC__byte *crc)
+{
+	const FLAC__byte *buffer;
+	size_t bytes;
+
+	FLAC__ASSERT((bw->bits & 7) == 0); /* assert that we're byte-aligned */
+
+	if(!FLAC__bitwriter_get_buffer(bw, &buffer, &bytes))
+		return false;
+
+	*crc = FLAC__crc8(buffer, bytes);
+	FLAC__bitwriter_release_buffer(bw);
+	return true;
+}
+
+FLAC__bool FLAC__bitwriter_is_byte_aligned(const FLAC__BitWriter *bw)
+{
+	return ((bw->bits & 7) == 0);
+}
+
+unsigned FLAC__bitwriter_get_input_bits_unconsumed(const FLAC__BitWriter *bw)
+{
+	return FLAC__TOTAL_BITS(bw);
+}
+
+FLAC__bool FLAC__bitwriter_get_buffer(FLAC__BitWriter *bw, const FLAC__byte **buffer, size_t *bytes)
+{
+	FLAC__ASSERT((bw->bits & 7) == 0);
+	/* double protection */
+	if(bw->bits & 7)
+		return false;
+	/* if we have bits in the accumulator we have to flush those to the buffer first */
+	if(bw->bits) {
+		FLAC__ASSERT(bw->words <= bw->capacity);
+		if(bw->words == bw->capacity && !bitwriter_grow_(bw, FLAC__BITS_PER_WORD))
+			return false;
+		/* append bits as complete word to buffer, but don't change bw->accum or bw->bits */
+		bw->buffer[bw->words] = SWAP_BE_WORD_TO_HOST(bw->accum << (FLAC__BITS_PER_WORD-bw->bits));
+	}
+	/* now we can just return what we have */
+	*buffer = (FLAC__byte*)bw->buffer;
+	*bytes = (FLAC__BYTES_PER_WORD * bw->words) + (bw->bits >> 3);
+	return true;
+}
+
+void FLAC__bitwriter_release_buffer(FLAC__BitWriter *bw)
+{
+	/* nothing to do.  in the future, strict checking of a 'writer-is-in-
+	 * get-mode' flag could be added everywhere and then cleared here
+	 */
+	(void)bw;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitwriter_write_zeroes(FLAC__BitWriter *bw, unsigned bits)
+{
+	unsigned n;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+
+	if(bits == 0)
+		return true;
+	/* slightly pessimistic size check but faster than "<= bw->words + (bw->bits+bits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD" */
+	if(bw->capacity <= bw->words + bits && !bitwriter_grow_(bw, bits))
+		return false;
+	/* first part gets to word alignment */
+	if(bw->bits) {
+		n = min(FLAC__BITS_PER_WORD - bw->bits, bits);
+		bw->accum <<= n;
+		bits -= n;
+		bw->bits += n;
+		if(bw->bits == FLAC__BITS_PER_WORD) {
+			bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
+			bw->bits = 0;
+		}
+		else
+			return true;
+	}
+	/* do whole words */
+	while(bits >= FLAC__BITS_PER_WORD) {
+		bw->buffer[bw->words++] = 0;
+		bits -= FLAC__BITS_PER_WORD;
+	}
+	/* do any leftovers */
+	if(bits > 0) {
+		bw->accum = 0;
+		bw->bits = bits;
+	}
+	return true;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_uint32(FLAC__BitWriter *bw, FLAC__uint32 val, unsigned bits)
+{
+	register unsigned left;
+
+	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
+	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+
+	FLAC__ASSERT(bits <= 32);
+	if(bits == 0)
+		return true;
+
+	/* slightly pessimistic size check but faster than "<= bw->words + (bw->bits+bits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD" */
+	if(bw->capacity <= bw->words + bits && !bitwriter_grow_(bw, bits))
+		return false;
+
+	left = FLAC__BITS_PER_WORD - bw->bits;
+	if(bits < left) {
+		bw->accum <<= bits;
+		bw->accum |= val;
+		bw->bits += bits;
+	}
+	else if(bw->bits) { /* WATCHOUT: if bw->bits == 0, left==FLAC__BITS_PER_WORD and bw->accum<<=left is a NOP instead of setting to 0 */
+		bw->accum <<= left;
+		bw->accum |= val >> (bw->bits = bits - left);
+		bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
+		bw->accum = val;
+	}
+	else {
+		bw->accum = val;
+		bw->bits = 0;
+		bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(val);
+	}
+
+	return true;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_int32(FLAC__BitWriter *bw, FLAC__int32 val, unsigned bits)
+{
+	/* zero-out unused bits */
+	if(bits < 32)
+		val &= (~(0xffffffff << bits));
+
+	return FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, bits);
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_uint64(FLAC__BitWriter *bw, FLAC__uint64 val, unsigned bits)
+{
+	/* this could be a little faster but it's not used for much */
+	if(bits > 32) {
+		return
+			FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)(val>>32), bits-32) &&
+			FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, 32);
+	}
+	else
+		return FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, bits);
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_uint32_little_endian(FLAC__BitWriter *bw, FLAC__uint32 val)
+{
+	/* this doesn't need to be that fast as currently it is only used for vorbis comments */
+
+	if(!FLAC__bitwriter_write_raw_uint32(bw, val & 0xff, 8))
+		return false;
+	if(!FLAC__bitwriter_write_raw_uint32(bw, (val>>8) & 0xff, 8))
+		return false;
+	if(!FLAC__bitwriter_write_raw_uint32(bw, (val>>16) & 0xff, 8))
+		return false;
+	if(!FLAC__bitwriter_write_raw_uint32(bw, val>>24, 8))
+		return false;
+
+	return true;
+}
+
+FLaC__INLINE FLAC__bool FLAC__bitwriter_write_byte_block(FLAC__BitWriter *bw, const FLAC__byte vals[], unsigned nvals)
+{
+	unsigned i;
+
+	/* this could be faster but currently we don't need it to be since it's only used for writing metadata */
+	for(i = 0; i < nvals; i++) {
+		if(!FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)(vals[i]), 8))
+			return false;
+	}
+
+	return true;
+}
+
+FLAC__bool FLAC__bitwriter_write_unary_unsigned(FLAC__BitWriter *bw, unsigned val)
+{
+	if(val < 32)
+		return FLAC__bitwriter_write_raw_uint32(bw, 1, ++val);
+	else
+		return
+			FLAC__bitwriter_write_zeroes(bw, val) &&
+			FLAC__bitwriter_write_raw_uint32(bw, 1, 1);
+}
+
+unsigned FLAC__bitwriter_rice_bits(FLAC__int32 val, unsigned parameter)
+{
+	FLAC__uint32 uval;
+
+	FLAC__ASSERT(parameter < sizeof(unsigned)*8);
+
+	/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */
+	uval = (val<<1) ^ (val>>31);
+
+	return 1 + parameter + (uval >> parameter);
+}
+
+#if 0 /* UNUSED */
+unsigned FLAC__bitwriter_golomb_bits_signed(int val, unsigned parameter)
+{
+	unsigned bits, msbs, uval;
+	unsigned k;
+
+	FLAC__ASSERT(parameter > 0);
+
+	/* fold signed to unsigned */
+	if(val < 0)
+		uval = (unsigned)(((-(++val)) << 1) + 1);
+	else
+		uval = (unsigned)(val << 1);
+
+	k = FLAC__bitmath_ilog2(parameter);
+	if(parameter == 1u<<k) {
+		FLAC__ASSERT(k <= 30);
+
+		msbs = uval >> k;
+		bits = 1 + k + msbs;
+	}
+	else {
+		unsigned q, r, d;
+
+		d = (1 << (k+1)) - parameter;
+		q = uval / parameter;
+		r = uval - (q * parameter);
+
+		bits = 1 + q + k;
+		if(r >= d)
+			bits++;
+	}
+	return bits;
+}
+
+unsigned FLAC__bitwriter_golomb_bits_unsigned(unsigned uval, unsigned parameter)
+{
+	unsigned bits, msbs;
+	unsigned k;
+
+	FLAC__ASSERT(parameter > 0);
+
+	k = FLAC__bitmath_ilog2(parameter);
+	if(parameter == 1u<<k) {
+		FLAC__ASSERT(k <= 30);
+
+		msbs = uval >> k;
+		bits = 1 + k + msbs;
+	}
+	else {
+		unsigned q, r, d;
+
+		d = (1 << (k+1)) - parameter;
+		q = uval / parameter;
+		r = uval - (q * parameter);
+
+		bits = 1 + q + k;
+		if(r >= d)
+			bits++;
+	}
+	return bits;
+}
+#endif /* UNUSED */
+
+FLAC__bool FLAC__bitwriter_write_rice_signed(FLAC__BitWriter *bw, FLAC__int32 val, unsigned parameter)
+{
+	unsigned total_bits, interesting_bits, msbs;
+	FLAC__uint32 uval, pattern;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+	FLAC__ASSERT(parameter < 8*sizeof(uval));
+
+	/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */
+	uval = (val<<1) ^ (val>>31);
+
+	msbs = uval >> parameter;
+	interesting_bits = 1 + parameter;
+	total_bits = interesting_bits + msbs;
+	pattern = 1 << parameter; /* the unary end bit */
+	pattern |= (uval & ((1<<parameter)-1)); /* the binary LSBs */
+
+	if(total_bits <= 32)
+		return FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits);
+	else
+		return
+			FLAC__bitwriter_write_zeroes(bw, msbs) && /* write the unary MSBs */
+			FLAC__bitwriter_write_raw_uint32(bw, pattern, interesting_bits); /* write the unary end bit and binary LSBs */
+}
+
+FLAC__bool FLAC__bitwriter_write_rice_signed_block(FLAC__BitWriter *bw, const FLAC__int32 *vals, unsigned nvals, unsigned parameter)
+{
+	const FLAC__uint32 mask1 = FLAC__WORD_ALL_ONES << parameter; /* we val|=mask1 to set the stop bit above it... */
+	const FLAC__uint32 mask2 = FLAC__WORD_ALL_ONES >> (31-parameter); /* ...then mask off the bits above the stop bit with val&=mask2*/
+	FLAC__uint32 uval;
+	unsigned left;
+	const unsigned lsbits = 1 + parameter;
+	unsigned msbits;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+	FLAC__ASSERT(parameter < 8*sizeof(bwword)-1);
+	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
+	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
+
+	while(nvals) {
+		/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */
+		uval = (*vals<<1) ^ (*vals>>31);
+
+		msbits = uval >> parameter;
+
+#if 0 /* OPT: can remove this special case if it doesn't make up for the extra compare (doesn't make a statistically significant difference with msvc or gcc/x86) */
+		if(bw->bits && bw->bits + msbits + lsbits <= FLAC__BITS_PER_WORD) { /* i.e. if the whole thing fits in the current bwword */
+			/* ^^^ if bw->bits is 0 then we may have filled the buffer and have no free bwword to work in */
+			bw->bits = bw->bits + msbits + lsbits;
+			uval |= mask1; /* set stop bit */
+			uval &= mask2; /* mask off unused top bits */
+			/* NOT: bw->accum <<= msbits + lsbits because msbits+lsbits could be 32, then the shift would be a NOP */
+			bw->accum <<= msbits;
+			bw->accum <<= lsbits;
+			bw->accum |= uval;
+			if(bw->bits == FLAC__BITS_PER_WORD) {
+				bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
+				bw->bits = 0;
+				/* burying the capacity check down here means we have to grow the buffer a little if there are more vals to do */
+				if(bw->capacity <= bw->words && nvals > 1 && !bitwriter_grow_(bw, 1)) {
+					FLAC__ASSERT(bw->capacity == bw->words);
+					return false;
+				}
+			}
+		}
+		else {
+#elif 1 /*@@@@@@ OPT: try this version with MSVC6 to see if better, not much difference for gcc-4 */
+		if(bw->bits && bw->bits + msbits + lsbits < FLAC__BITS_PER_WORD) { /* i.e. if the whole thing fits in the current bwword */
+			/* ^^^ if bw->bits is 0 then we may have filled the buffer and have no free bwword to work in */
+			bw->bits = bw->bits + msbits + lsbits;
+			uval |= mask1; /* set stop bit */
+			uval &= mask2; /* mask off unused top bits */
+			bw->accum <<= msbits + lsbits;
+			bw->accum |= uval;
+		}
+		else {
+#endif
+			/* slightly pessimistic size check but faster than "<= bw->words + (bw->bits+msbits+lsbits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD" */
+			/* OPT: pessimism may cause flurry of false calls to grow_ which eat up all savings before it */
+			if(bw->capacity <= bw->words + bw->bits + msbits + 1/*lsbits always fit in 1 bwword*/ && !bitwriter_grow_(bw, msbits+lsbits))
+				return false;
+
+			if(msbits) {
+				/* first part gets to word alignment */
+				if(bw->bits) {
+					left = FLAC__BITS_PER_WORD - bw->bits;
+					if(msbits < left) {
+						bw->accum <<= msbits;
+						bw->bits += msbits;
+						goto break1;
+					}
+					else {
+						bw->accum <<= left;
+						msbits -= left;
+						bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
+						bw->bits = 0;
+					}
+				}
+				/* do whole words */
+				while(msbits >= FLAC__BITS_PER_WORD) {
+					bw->buffer[bw->words++] = 0;
+					msbits -= FLAC__BITS_PER_WORD;
+				}
+				/* do any leftovers */
+				if(msbits > 0) {
+					bw->accum = 0;
+					bw->bits = msbits;
+				}
+			}
+break1:
+			uval |= mask1; /* set stop bit */
+			uval &= mask2; /* mask off unused top bits */
+
+			left = FLAC__BITS_PER_WORD - bw->bits;
+			if(lsbits < left) {
+				bw->accum <<= lsbits;
+				bw->accum |= uval;
+				bw->bits += lsbits;
+			}
+			else {
+				/* if bw->bits == 0, left==FLAC__BITS_PER_WORD which will always
+				 * be > lsbits (because of previous assertions) so it would have
+				 * triggered the (lsbits<left) case above.
+				 */
+				FLAC__ASSERT(bw->bits);
+				FLAC__ASSERT(left < FLAC__BITS_PER_WORD);
+				bw->accum <<= left;
+				bw->accum |= uval >> (bw->bits = lsbits - left);
+				bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
+				bw->accum = uval;
+			}
+#if 1
+		}
+#endif
+		vals++;
+		nvals--;
+	}
+	return true;
+}
+
+#if 0 /* UNUSED */
+FLAC__bool FLAC__bitwriter_write_golomb_signed(FLAC__BitWriter *bw, int val, unsigned parameter)
+{
+	unsigned total_bits, msbs, uval;
+	unsigned k;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+	FLAC__ASSERT(parameter > 0);
+
+	/* fold signed to unsigned */
+	if(val < 0)
+		uval = (unsigned)(((-(++val)) << 1) + 1);
+	else
+		uval = (unsigned)(val << 1);
+
+	k = FLAC__bitmath_ilog2(parameter);
+	if(parameter == 1u<<k) {
+		unsigned pattern;
+
+		FLAC__ASSERT(k <= 30);
+
+		msbs = uval >> k;
+		total_bits = 1 + k + msbs;
+		pattern = 1 << k; /* the unary end bit */
+		pattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */
+
+		if(total_bits <= 32) {
+			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))
+				return false;
+		}
+		else {
+			/* write the unary MSBs */
+			if(!FLAC__bitwriter_write_zeroes(bw, msbs))
+				return false;
+			/* write the unary end bit and binary LSBs */
+			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))
+				return false;
+		}
+	}
+	else {
+		unsigned q, r, d;
+
+		d = (1 << (k+1)) - parameter;
+		q = uval / parameter;
+		r = uval - (q * parameter);
+		/* write the unary MSBs */
+		if(!FLAC__bitwriter_write_zeroes(bw, q))
+			return false;
+		/* write the unary end bit */
+		if(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))
+			return false;
+		/* write the binary LSBs */
+		if(r >= d) {
+			if(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))
+				return false;
+		}
+		else {
+			if(!FLAC__bitwriter_write_raw_uint32(bw, r, k))
+				return false;
+		}
+	}
+	return true;
+}
+
+FLAC__bool FLAC__bitwriter_write_golomb_unsigned(FLAC__BitWriter *bw, unsigned uval, unsigned parameter)
+{
+	unsigned total_bits, msbs;
+	unsigned k;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+	FLAC__ASSERT(parameter > 0);
+
+	k = FLAC__bitmath_ilog2(parameter);
+	if(parameter == 1u<<k) {
+		unsigned pattern;
+
+		FLAC__ASSERT(k <= 30);
+
+		msbs = uval >> k;
+		total_bits = 1 + k + msbs;
+		pattern = 1 << k; /* the unary end bit */
+		pattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */
+
+		if(total_bits <= 32) {
+			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))
+				return false;
+		}
+		else {
+			/* write the unary MSBs */
+			if(!FLAC__bitwriter_write_zeroes(bw, msbs))
+				return false;
+			/* write the unary end bit and binary LSBs */
+			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))
+				return false;
+		}
+	}
+	else {
+		unsigned q, r, d;
+
+		d = (1 << (k+1)) - parameter;
+		q = uval / parameter;
+		r = uval - (q * parameter);
+		/* write the unary MSBs */
+		if(!FLAC__bitwriter_write_zeroes(bw, q))
+			return false;
+		/* write the unary end bit */
+		if(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))
+			return false;
+		/* write the binary LSBs */
+		if(r >= d) {
+			if(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))
+				return false;
+		}
+		else {
+			if(!FLAC__bitwriter_write_raw_uint32(bw, r, k))
+				return false;
+		}
+	}
+	return true;
+}
+#endif /* UNUSED */
+
+FLAC__bool FLAC__bitwriter_write_utf8_uint32(FLAC__BitWriter *bw, FLAC__uint32 val)
+{
+	FLAC__bool ok = 1;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+
+	FLAC__ASSERT(!(val & 0x80000000)); /* this version only handles 31 bits */
+
+	if(val < 0x80) {
+		return FLAC__bitwriter_write_raw_uint32(bw, val, 8);
+	}
+	else if(val < 0x800) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xC0 | (val>>6), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
+	}
+	else if(val < 0x10000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xE0 | (val>>12), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
+	}
+	else if(val < 0x200000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF0 | (val>>18), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
+	}
+	else if(val < 0x4000000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF8 | (val>>24), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>18)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
+	}
+	else {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFC | (val>>30), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>24)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>18)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
+	}
+
+	return ok;
+}
+
+FLAC__bool FLAC__bitwriter_write_utf8_uint64(FLAC__BitWriter *bw, FLAC__uint64 val)
+{
+	FLAC__bool ok = 1;
+
+	FLAC__ASSERT(0 != bw);
+	FLAC__ASSERT(0 != bw->buffer);
+
+	FLAC__ASSERT(!(val & FLAC__U64L(0xFFFFFFF000000000))); /* this version only handles 36 bits */
+
+	if(val < 0x80) {
+		return FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, 8);
+	}
+	else if(val < 0x800) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xC0 | (FLAC__uint32)(val>>6), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
+	}
+	else if(val < 0x10000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xE0 | (FLAC__uint32)(val>>12), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
+	}
+	else if(val < 0x200000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF0 | (FLAC__uint32)(val>>18), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
+	}
+	else if(val < 0x4000000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF8 | (FLAC__uint32)(val>>24), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
+	}
+	else if(val < 0x80000000) {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFC | (FLAC__uint32)(val>>30), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>24)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
+	}
+	else {
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFE, 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>30)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>24)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
+		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
+	}
+
+	return ok;
+}
+
+FLAC__bool FLAC__bitwriter_zero_pad_to_byte_boundary(FLAC__BitWriter *bw)
+{
+	/* 0-pad to byte boundary */
+	if(bw->bits & 7u)
+		return FLAC__bitwriter_write_zeroes(bw, 8 - (bw->bits & 7u));
+	else
+		return true;
+}
